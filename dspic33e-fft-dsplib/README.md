![image](../images/microchip.jpg)

##  FFT DSPLIB

## Description:

Microchip's 16-bit dsPIC® Digital Signal Controllers feature a DSP Engine in the CPU that is capable of executing a Fast Fourier Transform (FFT) 
with great efficiency (high speed and low RAM usage). The on-chip features enabling the FFT implementation include, bit-reversed addressing,
Multiply-accumulate (MAC) type instructions and the ability to store and retrieve constants stored in Program memory.

Microchip provides a DSP functions library that provides in-place FFT functions.

In this code example, we demonstrate how the DSP library functions can be used to perform an FFT on an input signal (vector). The code example is
reconfigurable to perfrom an FFT of any size, including common sizes of 64, 128, 256 and 512 points. The code example also allows the user to place 
the FFT coefficients (known as Twiddle Factors) in RAM or in Program Flash Memory. The project may be easily reconfigured by modifying the header
 file, FFT.h. By default, the example implements a 256-point FFT using coefficients stored in Program Flash memory.

The input signal for our example will be 256 points of a Square wave signal of frequency 1KHz sampled at 10 KHz. This signal was first generated by
 dsPICworks and then exported as an assembler file from dsPICworks. After exporting it out, the assembler file was modified to ensure the samples
 reside in Y-data space.

The FFT operation is performed on the input signal, in-place. This means that the output of the FFT resides in the same RAM locations where the
 input signal used to reside. The FFT is performed in the following steps:

1.Initialization: Generate Twiddle Factor Coefficients and store them in X-RAM or alternately use twiddle factor coefficients stored in
 Program Flash.

2.Scale the input signal to lie within the range [-0.5, +0.5]. For fixed point fractional input data, this translates to input samples in 
the range [0xC000,0x3FFF]. The scaling is achieved by simply right-shifting the input samples by 1 bit, assuming the input samples lie 
in the fixed point range [0x8000,0x7FFF] or [-1,+1).

3.Convert the real input signal vector to a complex vector by placing zeros in every other location to signify a complex input whose
 imaginary part is 0x0000.

4.Butterfly computation: This is achieved by performing a call to the FFTComplexIP() function.

5.Bit-Reversed Re-ordering: The output array is re-ordered to be in bit-reversed order of the addresses. This is achieved by a function
 call to BitReverseComplex().

6.SquareMagnitude computation: We then need to compute the magnitude of each complex element in the output vector, so that we can estimate 
the energy in each spectral component/frequency bin. This is achieved by a call to a special C-callable routine, SquareMagnitudeCplx(), 
written in assembler language. This routine will  be incorporated into the DSP library in future revisions of the C30 toolsuite. At that time,
 you may remove the source file, cplxsqrmag.s from the project and include the latest DSP library file, libdsp-coff.a.

7.Peak-picking: We then find the frequency component with the largest energy by using the VectorMax() routine in the DSP library.

8.Frequency Calculation: The value of the spectral component with the highest energy, in Hz, is calculated by multiplying the array index of 
the largest element in the output array with the spectral (bin) resolution ( = sampling rate/FFT size).

## Hardware Used

- Explorer 16/32 Development Board (https://www.microchip.com/DM240001-2)
- dsPIC33EP512GM710 PIM (https://www.microchip.com/ma330035) or dsPIC33EP512MU810 PIM (https://www.microchip.com/MA330025-1) or dsPIC33EP256GP506 PIM (https://www.microchip.com/MA330030)
	
	
## Software Used 

- MPLAB® X IDE v6.00 or newer (https://www.microchip.com/mplabx)
- MPLAB® XC16 v2.00 or newer (https://www.microchip.com/xc)

